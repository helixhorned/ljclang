local ffi=require"ffi"
return {
ErrorCode = ffi.new[[struct{
static const int Success = 0;
static const int Failure = 1;
static const int Crashed = 2;
static const int InvalidArguments = 3;
static const int ASTReadError = 4;
}]],
SaveError = ffi.new[[struct{
static const int None = 0;
static const int Unknown = 1;
static const int TranslationErrors = 2;
static const int InvalidTU = 3;
}]],
DiagnosticSeverity = ffi.new[[struct{
static const int Ignored = 0;
static const int Note = 1;
static const int Warning = 2;
static const int Error = 3;
static const int Fatal = 4;
}]],
ChildVisitResult = ffi.new[[struct{
static const int Break = 0;
static const int Continue = 1;
static const int Recurse = 2;
}]],
-- NOTE: this mixes the constants of the two enums typedef'd as CXIdxEntityKind and
--  CXIdxEntityCXXTemplateKind.
IdxEntity = ffi.new[[struct{
static const int Unexposed = 0;
static const int Typedef = 1;
static const int Function = 2;
static const int Variable = 3;
static const int Field = 4;
static const int EnumConstant = 5;
static const int Enum = 13;
static const int Struct = 14;
static const int Union = 15;
static const int CXXClass = 16;
static const int CXXNamespace = 17;
static const int CXXNamespaceAlias = 18;
static const int CXXStaticVariable = 19;
static const int CXXStaticMethod = 20;
static const int CXXInstanceMethod = 21;
static const int CXXConstructor = 22;
static const int CXXDestructor = 23;
static const int CXXConversionFunction = 24;
static const int CXXTypeAlias = 25;
static const int CXXInterface = 26;
static const int NonTemplate = 0;
static const int Template = 1;
static const int TemplatePartialSpecialization = 2;
static const int TemplateSpecialization = 3;
}]],
-- NOTE [ANONYMOUS_ENUM_WITH_TYPEDEF]: the enum type is anonymous here, but we are lucky
--  because the prefix of the enum constant names is unique to this particular enum type.
-- TODO: teach extractdecls to filter by the name of an immediate typedef.
IdxEntityLang = ffi.new[[struct{
static const int None = 0;
static const int C = 1;
static const int ObjC = 2;
static const int CXX = 3;
static const int Swift = 4;
}]],
IndexOpt = ffi.new[[struct{
static const int None = 0;
static const int SuppressRedundantRefs = 1;
static const int IndexFunctionLocalSymbols = 2;
static const int IndexImplicitTemplateInstantiations = 4;
static const int SuppressWarnings = 8;
static const int SkipParsedBodiesInSession = 16;
}]],
RefQualifierKind = ffi.new[[struct{
static const int None = 0;
static const int LValue = 1;
static const int RValue = 2;
}]],
-- NOTE ANONYMOUS_ENUM_WITH_TYPEDEF:
SymbolRole = ffi.new[[struct{
static const int None = 0;
static const int Declaration = 1;
static const int Definition = 2;
static const int Reference = 4;
static const int Read = 8;
static const int Write = 16;
static const int Call = 32;
static const int Dynamic = 64;
static const int AddressOf = 128;
static const int Implicit = 256;
}]],
CursorKindName = {
[1] = "UnexposedDecl";
[2] = "StructDecl";
[3] = "UnionDecl";
[4] = "ClassDecl";
[5] = "EnumDecl";
[6] = "FieldDecl";
[7] = "EnumConstantDecl";
[8] = "FunctionDecl";
[9] = "VarDecl";
[10] = "ParmDecl";
[11] = "ObjCInterfaceDecl";
[12] = "ObjCCategoryDecl";
[13] = "ObjCProtocolDecl";
[14] = "ObjCPropertyDecl";
[15] = "ObjCIvarDecl";
[16] = "ObjCInstanceMethodDecl";
[17] = "ObjCClassMethodDecl";
[18] = "ObjCImplementationDecl";
[19] = "ObjCCategoryImplDecl";
[20] = "TypedefDecl";
[21] = "CXXMethod";
[22] = "Namespace";
[23] = "LinkageSpec";
[24] = "Constructor";
[25] = "Destructor";
[26] = "ConversionFunction";
[27] = "TemplateTypeParameter";
[28] = "NonTypeTemplateParameter";
[29] = "TemplateTemplateParameter";
[30] = "FunctionTemplate";
[31] = "ClassTemplate";
[32] = "ClassTemplatePartialSpecialization";
[33] = "NamespaceAlias";
[34] = "UsingDirective";
[35] = "UsingDeclaration";
[36] = "TypeAliasDecl";
[37] = "ObjCSynthesizeDecl";
[38] = "ObjCDynamicDecl";
[39] = "CXXAccessSpecifier";
[40] = "ObjCSuperClassRef";
[41] = "ObjCProtocolRef";
[42] = "ObjCClassRef";
[43] = "TypeRef";
[44] = "CXXBaseSpecifier";
[45] = "TemplateRef";
[46] = "NamespaceRef";
[47] = "MemberRef";
[48] = "LabelRef";
[49] = "OverloadedDeclRef";
[50] = "VariableRef";
[70] = "InvalidFile";
[71] = "NoDeclFound";
[72] = "NotImplemented";
[73] = "InvalidCode";
[100] = "UnexposedExpr";
[101] = "DeclRefExpr";
[102] = "MemberRefExpr";
[103] = "CallExpr";
[104] = "ObjCMessageExpr";
[105] = "BlockExpr";
[106] = "IntegerLiteral";
[107] = "FloatingLiteral";
[108] = "ImaginaryLiteral";
[109] = "StringLiteral";
[110] = "CharacterLiteral";
[111] = "ParenExpr";
[112] = "UnaryOperator";
[113] = "ArraySubscriptExpr";
[114] = "BinaryOperator";
[115] = "CompoundAssignOperator";
[116] = "ConditionalOperator";
[117] = "CStyleCastExpr";
[118] = "CompoundLiteralExpr";
[119] = "InitListExpr";
[120] = "AddrLabelExpr";
[121] = "StmtExpr";
[122] = "GenericSelectionExpr";
[123] = "GNUNullExpr";
[124] = "CXXStaticCastExpr";
[125] = "CXXDynamicCastExpr";
[126] = "CXXReinterpretCastExpr";
[127] = "CXXConstCastExpr";
[128] = "CXXFunctionalCastExpr";
[129] = "CXXTypeidExpr";
[130] = "CXXBoolLiteralExpr";
[131] = "CXXNullPtrLiteralExpr";
[132] = "CXXThisExpr";
[133] = "CXXThrowExpr";
[134] = "CXXNewExpr";
[135] = "CXXDeleteExpr";
[136] = "UnaryExpr";
[137] = "ObjCStringLiteral";
[138] = "ObjCEncodeExpr";
[139] = "ObjCSelectorExpr";
[140] = "ObjCProtocolExpr";
[141] = "ObjCBridgedCastExpr";
[142] = "PackExpansionExpr";
[143] = "SizeOfPackExpr";
[144] = "LambdaExpr";
[145] = "ObjCBoolLiteralExpr";
[146] = "ObjCSelfExpr";
[147] = "OMPArraySectionExpr";
[148] = "ObjCAvailabilityCheckExpr";
[149] = "FixedPointLiteral";
[150] = "OMPArrayShapingExpr";
[151] = "OMPIteratorExpr";
[152] = "CXXAddrspaceCastExpr";
[200] = "UnexposedStmt";
[201] = "LabelStmt";
[202] = "CompoundStmt";
[203] = "CaseStmt";
[204] = "DefaultStmt";
[205] = "IfStmt";
[206] = "SwitchStmt";
[207] = "WhileStmt";
[208] = "DoStmt";
[209] = "ForStmt";
[210] = "GotoStmt";
[211] = "IndirectGotoStmt";
[212] = "ContinueStmt";
[213] = "BreakStmt";
[214] = "ReturnStmt";
[215] = "AsmStmt";
[216] = "ObjCAtTryStmt";
[217] = "ObjCAtCatchStmt";
[218] = "ObjCAtFinallyStmt";
[219] = "ObjCAtThrowStmt";
[220] = "ObjCAtSynchronizedStmt";
[221] = "ObjCAutoreleasePoolStmt";
[222] = "ObjCForCollectionStmt";
[223] = "CXXCatchStmt";
[224] = "CXXTryStmt";
[225] = "CXXForRangeStmt";
[226] = "SEHTryStmt";
[227] = "SEHExceptStmt";
[228] = "SEHFinallyStmt";
[229] = "MSAsmStmt";
[230] = "NullStmt";
[231] = "DeclStmt";
[232] = "OMPParallelDirective";
[233] = "OMPSimdDirective";
[234] = "OMPForDirective";
[235] = "OMPSectionsDirective";
[236] = "OMPSectionDirective";
[237] = "OMPSingleDirective";
[238] = "OMPParallelForDirective";
[239] = "OMPParallelSectionsDirective";
[240] = "OMPTaskDirective";
[241] = "OMPMasterDirective";
[242] = "OMPCriticalDirective";
[243] = "OMPTaskyieldDirective";
[244] = "OMPBarrierDirective";
[245] = "OMPTaskwaitDirective";
[246] = "OMPFlushDirective";
[247] = "SEHLeaveStmt";
[248] = "OMPOrderedDirective";
[249] = "OMPAtomicDirective";
[250] = "OMPForSimdDirective";
[251] = "OMPParallelForSimdDirective";
[252] = "OMPTargetDirective";
[253] = "OMPTeamsDirective";
[254] = "OMPTaskgroupDirective";
[255] = "OMPCancellationPointDirective";
[256] = "OMPCancelDirective";
[257] = "OMPTargetDataDirective";
[258] = "OMPTaskLoopDirective";
[259] = "OMPTaskLoopSimdDirective";
[260] = "OMPDistributeDirective";
[261] = "OMPTargetEnterDataDirective";
[262] = "OMPTargetExitDataDirective";
[263] = "OMPTargetParallelDirective";
[264] = "OMPTargetParallelForDirective";
[265] = "OMPTargetUpdateDirective";
[266] = "OMPDistributeParallelForDirective";
[267] = "OMPDistributeParallelForSimdDirective";
[268] = "OMPDistributeSimdDirective";
[269] = "OMPTargetParallelForSimdDirective";
[270] = "OMPTargetSimdDirective";
[271] = "OMPTeamsDistributeDirective";
[272] = "OMPTeamsDistributeSimdDirective";
[273] = "OMPTeamsDistributeParallelForSimdDirective";
[274] = "OMPTeamsDistributeParallelForDirective";
[275] = "OMPTargetTeamsDirective";
[276] = "OMPTargetTeamsDistributeDirective";
[277] = "OMPTargetTeamsDistributeParallelForDirective";
[278] = "OMPTargetTeamsDistributeParallelForSimdDirective";
[279] = "OMPTargetTeamsDistributeSimdDirective";
[280] = "BuiltinBitCastExpr";
[281] = "OMPMasterTaskLoopDirective";
[282] = "OMPParallelMasterTaskLoopDirective";
[283] = "OMPMasterTaskLoopSimdDirective";
[284] = "OMPParallelMasterTaskLoopSimdDirective";
[285] = "OMPParallelMasterDirective";
[286] = "OMPDepobjDirective";
[287] = "OMPScanDirective";
[300] = "TranslationUnit";
[400] = "UnexposedAttr";
[401] = "IBActionAttr";
[402] = "IBOutletAttr";
[403] = "IBOutletCollectionAttr";
[404] = "CXXFinalAttr";
[405] = "CXXOverrideAttr";
[406] = "AnnotateAttr";
[407] = "AsmLabelAttr";
[408] = "PackedAttr";
[409] = "PureAttr";
[410] = "ConstAttr";
[411] = "NoDuplicateAttr";
[412] = "CUDAConstantAttr";
[413] = "CUDADeviceAttr";
[414] = "CUDAGlobalAttr";
[415] = "CUDAHostAttr";
[416] = "CUDASharedAttr";
[417] = "VisibilityAttr";
[418] = "DLLExport";
[419] = "DLLImport";
[420] = "NSReturnsRetained";
[421] = "NSReturnsNotRetained";
[422] = "NSReturnsAutoreleased";
[423] = "NSConsumesSelf";
[424] = "NSConsumed";
[425] = "ObjCException";
[426] = "ObjCNSObject";
[427] = "ObjCIndependentClass";
[428] = "ObjCPreciseLifetime";
[429] = "ObjCReturnsInnerPointer";
[430] = "ObjCRequiresSuper";
[431] = "ObjCRootClass";
[432] = "ObjCSubclassingRestricted";
[433] = "ObjCExplicitProtocolImpl";
[434] = "ObjCDesignatedInitializer";
[435] = "ObjCRuntimeVisible";
[436] = "ObjCBoxable";
[437] = "FlagEnum";
[438] = "ConvergentAttr";
[439] = "WarnUnusedAttr";
[440] = "WarnUnusedResultAttr";
[441] = "AlignedAttr";
[500] = "PreprocessingDirective";
[501] = "MacroDefinition";
[502] = "MacroExpansion";
[503] = "InclusionDirective";
[600] = "ModuleImportDecl";
[601] = "TypeAliasTemplateDecl";
[602] = "StaticAssert";
[603] = "FriendDecl";
[700] = "OverloadCandidate";
},
}
