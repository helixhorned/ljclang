#!/bin/false
-- Usage: luajit -l mkapp <program>.lua [<args...>]

-- NOTE: relies on package.searchpath for its core functionality which is undocumented by
--  Lua 5.1 (and neither by LuaJIT, it seems)

local assert = assert
local print = print
local require = require
local type = type

local io = io
local os = os
local package = package
local string = string
local table = table

local format = string.format
local open = io.open

local arg = arg
local _G = _G

----------

local function printf(fmt, ...)
    print(format("mkapp: "..fmt, ...))
end

local function errprint(str)
    io.stderr:write("mkapp: "..str.."\n")
end

local function errprintf(fmt, ...)
    errprint(format(fmt, ...))
end

-- TODO: if no file modules encountered, just output the main file under the new name.

-- Among other things, used for cases where we cannot proceed with processing
--  (e.g. file I/O encountered)
-- NOTE: do not merely error() so that code wrapped cannot pcall() it.
-- TODO: think about other places where we would like to terminate on presence of a thrown
--  error instead of allowing it to propagate?
local function errprintfAndExit(fmt, ...)
    errprintf("ERROR: "..fmt, ...)
    os.exit(150)
end

----------

-- TODO: treat ffi.load() analogously. If the program has ffi.load() calls,
--  generate target identifier (something like the "triple") from
--  jit.os jit.arch ffi.abi(<relevant parameter>).
--  Do not *handle* shared library loads though. This would entail platform-specific work.

local level = 0

local progName = arg[0]
local outFileName = progName:match("%.lua$") and
    progName:gsub("%.lua$", ".app.lua") or
    progName..".app.lua"

----------

-- The generated .app.lua should be as stand-alone as possible, so disallow all Lua
-- functions taking a file name at app generation time.
local function abortDisallowedFunction(...)
    -- TODO: find out and print the name of the function?
    errprintfAndExit("Attempt to call disallowed function at app generation time")
end

-- List obtained by searching for 'filename' in the Lua 5.1 reference manual opened in w3m.
-- TODO: are there other functions by which any amount of information may be obtained about
--  any host file system state? These may be reasonable candidates for disallowing, too.
_G.dofile = abortDisallowedFunction
_G.loadfile = abortDisallowedFunction
_G.io.lines = abortDisallowedFunction
_G.io.open = abortDisallowedFunction
_G.os.remove = abortDisallowedFunction

local io_input = io.input
_G.io.input = function(file)
    return (file ~= nil) and abortDisallowedFunction() or io_input(file)
end

local io_output = io.output
_G.io.output = function(file)
    return (file ~= nil) and abortDisallowedFunction() or io_output(file)
end

-- Be strict and disallowed a few other things.
_G.io.popen = abortDisallowedFunction
_G.os.execute = abortDisallowedFunction

----------

-- Will contain generated Lua code at sequential indexes.
-- (Generated by us, mixed with contents of the Lua files that are 'require'd.)
local code = {
    "",  -- place for the shebang
    "\n",
    "-- Application unity file generated by mkapp.lua of LJClang, see\n",
    "-- https://github.com/helixhorned/ljclang\n",
    "-- NOTE: this does not say anything about the authorship or any\n",
    "--  other property of the constituent files of this amalgamation!\n",
    "\n",
    "local __LJClang_MkApp_Modules = {require}\n"
}

code[#code + 1] = [==[
-- mkapp.lua: override require() ========================================================================
local require
do
  local error=error
  local orig_require=__LJClang_MkApp_Modules[1]
  __LJClang_MkApp_Modules[1]=nil

  require = function(m)
    local t=__LJClang_MkApp_Modules[m]
    if t==nil then error("module '"..m.."' not included in .app.lua, please contact app and/or mkapp.lua maintainer") end
    return (t==true) and orig_require(m) or t
  end
end
]==]

local function addFileContents(f)
    code[#code + 1] = f:read("*a")
    f:close()
end

local function addCodeForFile(fileName)
    local f = open(fileName)
    if (f == nil) then
        errprintfAndExit("Failed opening '%s'", fileName)
    end

    code[#code + 1] = "(function()\n"
    addFileContents(f)
    -- NOTE: in the generated code, immediately execute the module function.
    code[#code + 1] = "end)()\n"
end

local haveBuiltinModule = {}
local lastModuleWasBuiltin = false

_G.require = function(module)
    assert(type(module) == "string")

    level = level + 1

    local fileName = package.searchpath(module, package.path)
    local wasLoaded = (package.loaded[module] ~= nil)

    -- TODO: error/warn/have-option if not in current directory or beneath?
    printf("[%d] REQUIRE %s -> %s%s",
           level, module, (fileName or "(built-in)"),
           wasLoaded and "" or " [first time]")

    local tab = require(module)

    if (type(tab) ~= "table") then
        errprintfAndExit("require() must return table")
    end

    assert(package.loaded[module] == tab)

    if (fileName == nil) then
        -- Built-in module. We cannot rely on 'package.loaded': some (like 'bit') are
        -- pre-loaded, others (like 'ffi') are not.
        if (not haveBuiltinModule[module]) then
            if (not lastModuleWasBuiltin) then
                code[#code + 1] = format("-- mkapp.lua: built-in modules %s\n", ("="):rep(94 - 21))
                lastModuleWasBuiltin = true
            end
            code[#code + 1] = format("__LJClang_MkApp_Modules[%q]=true\n", module)
            haveBuiltinModule[module] = true
        end
    elseif (not wasLoaded) then
        -- Module loaded first time from file.
        printf("GENCODE %s -> %s", module, fileName)

        code[#code + 1] = format("-- mkapp.lua: file module %s\n", ("="):rep(99 - 21))
        code[#code + 1] = format("__LJClang_MkApp_Modules[%q]=", module)
        lastModuleWasBuiltin = false

        addCodeForFile(fileName)
    end

    level = level - 1

    return tab
end

local function writeCode(fileName)
    local f, msg = open(fileName, "w")
    if (f == nil) then
        errprintfAndExit("%s", msg)
    end

    f:write(table.concat(code))
end

local os_exit = os.exit
_G.os.exit = function(errorCode)
    print()

    if (errorCode == 0) then
        local f = open(progName)
        if (f == nil) then
            errprintfAndExit("Failed opening '%s'", progName)
        end

        local shebang = f:read("*l")
        if (not shebang:match("^#!/")) then
            errprintfAndExit("Main file %s must start with a shebang ('#!/')")
        end
        code[1] = shebang..'\n'
        code[#code + 1] = [[
-- mkapp.lua: main =====================================================================================
]]
        addFileContents(f)

        printf("Writing %s", outFileName)
        writeCode(outFileName)
    else
        -- TODO: what if the application does not call os.exit() at all?
        printf("Not writing anything: application exits with non-zero code.")
    end

    os_exit(errorCode)
end
