
LJClang -- A LuaJIT-based interface to libclang
===============================================

Introduction
------------

[LuaJIT]: http://luajit.org/
[libclang]: http://clang.llvm.org/doxygen/group__CINDEX.html
[luaclang-parser]: https://github.com/mkottman/luaclang-parser

LJClang is an interface to [libclang] for [LuaJIT], modeled after and mostly
API-compatible with [luaclang-parser] by Michal Kottman.


Requirements
------------

* LuaJIT 2.0 or greater

* LLVM/Clang -- from the Linux distribution or
  [here](http://apt.llvm.org/). Development is done using the latest stable
  version, but older versions should work mostly fine (except that interfaces
  exposed by newer version are not available, of course).


Building
--------

The following command builds the required support library `libljclang_support.so`,
converts libclang C headers into a form that can be used by LuaJIT (using a Lua
program that essentially strips text that would not be understood by LuaJIT's
`ffi.cdef`) and finally extracts additional information using LJClang itself:

~~~~~~~~~~
LLVM_CONFIG=</path/to/llvm-config> make
~~~~~~~~~~


Overview
--------

LJClang provides a cursor-based, callback-driven API to the abstract syntax
tree (AST) of C/C++ source files. These are the main classes:

* `Index` -- represents a set of translation units that could be linked together
* `TranslationUnit` -- a source file together with everything included by it
  either directly or transitively
* `Cursor` -- points to an element in the AST in a translation unit such as a
  `typedef` declaration or a statement
* `Type` -- the type of an element (for example, that of a variable, structure
  member, or a function's input argument or return value)

To make something interesting happen, you usually create a single `Index`
object, parse into it one or more translation units, and define a callback
function to be invoked on each visit of a `Cursor` by libclang.


Example program
---------------

[`enum CXCursorKind`]:
 http://clang.llvm.org/doxygen/group__CINDEX.html#gaaccc432245b4cd9f2d470913f9ef0013

The `extractdecls.lua` script accompanied by LJClang can be used to extract
various kinds of C declarations from (usually) headers and print them in
various forms usable as FFI C declarations or descriptive tables with LuaJIT.

~~~~~~~~~~
Usage: ./extractdecls.lua [our options...] <file.h> [-- [Clang command line args ...]]
 (Our options may also come after the file name.)
  -e <enumNameFilterPattern> (enums only)
  -p <filterPattern>
  -x <excludePattern1> [-x <excludePattern2>] ...
  -s <stripPattern>
  -1 <string to print before everything>
  -2 <string to print after everything>
  -A <single Clang command line arg> (same as if specified as positional arg)
  -C: print lines like
       static const int membname = 123;  (enums/macros only)
  -R: reverse mapping, only if one-to-one. Print lines like
       [123] = "membname";  (enums/macros only)
  -f <formatFunc>: user-provided body for formatting function (enums/macros only)
       Arguments to that function are named
         * 'k' (enum constant / macro name)
         * 'v' (its numeric value)
         * 'enumName' (the name in 'enum <name>', or the empty string)
         * 'enumIntTypeName' (the name of the underlying integer type of an enum)
         * 'enumPrefixLength' (the length of the common prefix of all names; enums only)
       Also, the following is provided:
         * 'f' as a shorthand for 'string.format'
       Must return a formatted line.
       Example:
         "return f('%s = %s%s,', k, k:find('KEY_') and '65536+' or '', v)"
       Incompatible with -C or -R.
  -Q: be quiet
  -w: extract what? Can be
       EnumConstantDecl (default), TypedefDecl, FunctionDecl, MacroDefinition
~~~~~~~~~~

In fact, the file `ljclang_cursor_kind.lua` is generated by this program and is
used by LJClang to map values of the enumeration [`enum CXCursorKind`] to their
names. The `bootstrap` target in the `Makefile` extracts the relevant
information using these options:

~~~~~~~~~~
-Q -R -e 'CXCursorKind' -p '^CXCursor_' -s '^CXCursor_' \
    -x '_First' -x '_Last' -x '_GCCAsmStmt' -x '_MacroInstantiation' \
    -1 'CursorKindName = {' -2 '},'
~~~~~~~~~~


Thus, the enum constant names are filtered to be taken from `enum CXCursorKind`,
beginning with `CXCursor_` (that prefix being stripped) and all "secondary" names
aliasing the one considered the main one are rejected. (For example,
`CXCursor_AsmStmt` and `CXCursor_GCCAsmStmt` have the same value.) This yields
lines like

~~~~~~~~~~
[215] = "AsmStmt";
~~~~~~~~~~


Reference
---------

The module returned by `require("ljclang")` -- called `clang` from here on --
contains the following:

#### `index = clang.createIndex([excludeDeclarationsFromPCH [, displayDiagnostics]])`

[`clang_createIndex`]:
 http://clang.llvm.org/doxygen/group__CINDEX.html#ga51eb9b38c18743bf2d824c6230e61f93

Binding for [`clang_createIndex`]. Will create an `Index` into which you can
parse `TranslationUnit`s. Both input arguments are optional and default to
**false**.

#### `clang.ChildVisitResult`

[`enum CXChildVisitResult`]:
 http://clang.llvm.org/doxygen/group__CINDEX__CURSOR__TRAVERSAL.html#ga99a9058656e696b622fbefaf5207d715

An object containing a mapping of names to values permissible as values returned
from cursor visitor callbacks. The names are identical with those in [`enum
CXChildVisitResult`] with the "`CXChildVisit_`" prefix removed: `Break`,
`Continue`, `Recurse`.

#### `visitorHandle = clang.regCursorVisitor(visitorFunc)`

Registers a child visitor callback function `visitorFunc` with LJClang,
returning a handle which can be passed to `Cursor:children()`. The callback
function receives two input arguments, `(cursor, parent)` -- with the cursors
of the currently visited entity as well as its parent, and must return a value
from the `ChildVisitResult` enumeration to indicate whether or how libclang
should carry on AST visiting.

CAUTION: The `cursor` passed to the visitor callback is only valid during one
particular callback invocation. If it is to be used after the function has
returned, it **must** be copied using the `Cursor` constructor mentioned below.

#### `permanentCursor = clang.Cursor(cursor)`

Creates a permanent cursor from one received by the visitor callback.

#### `clang.ErrorCode`

[`enum CXErrorCode`]:
 http://clang.llvm.org/doxygen/CXErrorCode_8h.html#adba17f287f8184fc266f2db4e669bf0f

An object containing a mapping of names to value representing success or various
error conditions. The names are identical with those in [`enum CXErrorCode`] with
the "`CXError_`" prefix removed.

### Index

#### `translationUnit, errorCode = index:parse(sourceFileName, cmdLineArgs [, opts])`

[`clang_parseTranslationUnit2`]:
 http://clang.llvm.org/doxygen/group__CINDEX__TRANSLATION__UNIT.html#ga494de0e725c5ae40cbdea5fa6081027d

[`CXTranslationUnit_*`]:
 http://clang.llvm.org/doxygen/group__CINDEX__TRANSLATION__UNIT.html#enum-members

Binding for [`clang_parseTranslationUnit2`]. This will parse a given source
file named `sourceFileName` with the command line arguments `cmdLineArgs` given
to the compiler, containing e.g. include paths or defines. If `sourceFile` is
the empty string, the source file is expected to be named in `cmdLineArgs`.

The optional argument `opts` is expected to be a sequence containing
[`CXTranslationUnit_*`] enum names without the `"CXTranslationUnit_"` prefix,
for example `{ "DetailedPreprocessingRecord", "SkipFunctionBodies" }`.

NOTE: Both `cmdLineArgs` and `opts` (if given) must not contain an element at index 0.

On failure, `translationUnit` is `nil` and `errorCode` (comparable against
values in `clang.ErrorCode`) can be examined.


License
-------

Copyright (C) 2013-2019 Philipp Kutin. MIT licensed. See LICENSE for details.
